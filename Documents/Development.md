Week 0:
This week, we came together as a group and determined what we should do for our final project. Initially, we were unsure what path (pun fully intended) 
we wanted to pursue. We discussed several ideas, such as mapping the states of board games or playing with large datasets. However, we found that most
of our ideas would not have been valid for our final project. For example, we could not use the states of a game board because they would form a tree
rather than a cyclic graph. After some deliberation, we decided that we wanted to work with coordinates and roads to find the most efficient path between
two points, with our efficiency defined in terms of distance. At first, we made a rough proposal with unclear definitions of what we would do, since we
had not yet figured this out for ourselves. However, after some more research and time, we developed a better idea of how we could use the A* algorithm to
traverse and analyze all the possible paths from point A to B and return the best path.

Week 1:
This week, we made significant progress in mapping (both puns fully intended) out the journey of our project and further defining what exactly we would need to accomplish in order to see our project to its fruition. With Thanksgiving break coming the following week, we decided as a group that we would all try to work on the project over break enough to have made enough progress to hit the ground running when we came back. We divided up tasks between all of us, and decided which areas each person in our group should focus on. We divided up tasks so that each person would have something to work on, but also had two tasks be split up between two people, so that we would still have communication. Since all the different parts of our project are interdependent, it is essential that we communicate well as a group and help one another out. We decided this week that we will implement our project using a Graph class that contains the graph data structure that models all of our waypoints, as well as a Node struct that is used by the graph to represent waypoints and link them together. The graph will have member functions that it uses to build and maintain itself. We will also have separate classes dedicated to our search algorithms. These classes may be used by the graph, or they may use the graph itself. This is an implementation decision that we will make as we continue on our project. We also outlined some clearer ideas about our visualization. We decided that we can plot our points without outlining the shape of California to begin, because our waypoints already distinctly outline the shape of California because of their high frequency. Then, we can draw a path from start to finish once we figure out the optimal route for our travelers to take on their journey.

Week 2:
Over break, we completed the makeGraph() function which iterates through both datasets and creates a vector of nodes objects. The nodes each contain a Longitude and Latitude double, as well as a vector of pairs which represent an edge. The reason we created a vector of pairs for edges is because each node will have an unknown amount of edges from the iterator's perspective. We learned that not every node has an edge, so we know that the search algorithms will require a check that will determine if a path is possible to/from a node. We also continued implementing the A* search and the BFS and plan to have these finished before the mid-project check-in. On A* search, the algorithm was implemented in the search function, but was not yet tested. We reorganized the github so that only the project's files are in the main directory. Finally, we created created dummy return values for every function so that we can use a makefile for ease of testing. Type 'make' and './roadmap' to test the project.

Week 3:
This week, we made some major progress in both our graph generation and searching algorithms, as well as verifying the functionality of our code. The most major change we made to our graph generation was generating and node pointers (Node *) in our vectors of edges in each graph node as opposed to using integer indices. Prior to this week, our edge vectors in the Graph::Node struct had been storing the ints containing the indices of neighbor nodes in the graph_ node vector. However, this implementation proved to be difficult for the search programs to use, since making them index the graph_ Node vector every time added significantly more work than simply changing the contents of the vector when populating it. There was also a potential namespace and accessing issues arising if we required the search programs to index the graph Node. We also made the Graph code vastly more readable and added some helpful comments. The A* search algorithm was tested using our full dataset, and able to output a list of nodes for some routes. However, we realized our graph was only storing edges on one side, so after fixing this and a few other bugs, the A* search was fully functional for our midpoint check-in. We tested A* using adjacent as well as distant nodes, and used the double the Euclidean distance between the start and endpoints as a reasonable limit for the route distance. The search successfully output an optimal route and total distance given two points on our graph.

(A * stuff, BFS stuff. It's probably okay and even good if this week is long because we made a lot of progress)

Lastly, we made a handful of test cases to test the portion of our project that we have done so far. We made a handful of test cases to check ouf graph generation based on values and patterns we know should exist, and did the same for the A* search using expected distances and paths. We will make test cases for BFS and continue to make more test cases for existing code. Our next big step is working on the visualization for our code and figuring out the best and most aesthetically appealing way to plot our nodes.

Week 4:
We finished the graphing visualization. It was generated by parsing through the node vector and extracting the latitude and longitude of each node. Then, each pair of latitudes and longitudes was scaled in accordance with the width and height of the visualization image. This scaling is dynamic and able to change with the image size, and the visualization nodes will be generated regardless of scale (and look better at higher resolutions, of course). The project will print a path in blue from the nearest start and end points in our dataset based on longitude and latitude. Lots of bugs debugged. We finished our presentation and recorded the video. Our final task is to finish the readme.
